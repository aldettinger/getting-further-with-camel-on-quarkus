= Camel-Quarkus Demo

== How to Prepare the Demo

[source,shell]
----
# Provision "OpenShift 4 Serverless Foundations Lab" cluster and login, for instance:
oc login https://api.cluster-4098.4098.sandbox1083.opentlc.com:6443

# Create knative-serving namespace
oc create namespace knative-serving

# Install OpenShift ServerLess Operator from the UI (https://docs.openshift.com/container-platform/4.6/serverless/installing_serverless/installing-openshift-serverless.html)
+ Operators/Operator Hub/Fitler (OpenShift ServerLess)
+ Click Install / Subscribe
+ Click "Installed Operators" / "OpenShift Serverless" / "KNative Serving - Create Instance "
+ In the YAML view, set namespace to knative-serving
+ Click create
+ watch oc get pods -n knative-serving (wait all pods to be ready)

# Deploy jvm and native projects to the cluster
cd ~/dev/demos/camel-quarkus-demo/getting-further-with-camel-on-quarkus
mvn clean package -Dquarkus.kubernetes.deploy=true

# Finalize the configuration
oc apply -f openshift-configs/limit-range.yaml
kn ksvc update hello-cq-knative-jvm-mode --request memory=600Mi
kn ksvc update bye-cq-knative-jvm-mode --request memory=600Mi
kn ksvc update hello-cq-knative-native-mode --request memory=50Mi
kn ksvc update bye-cq-knative-native-mode --request memory=50Mi
oc apply -f openshift-configs/mem-quota.yaml

# Check that mem requests were applied
oc get ksvc hello-cq-knative-jvm-mode -o json | grep request -A 1
oc get ksvc hello-cq-knative-native-mode -o json | grep request -A 1
oc get ksvc bye-cq-knative-jvm-mode -o json | grep request -A 1
oc get ksvc bye-cq-knative-native-mode -o json | grep request -A 1

# Check the knative version (expected 0.16.0)
oc get namespace knative-serving -o 'go-template={{index .metadata.labels "serving.knative.dev/release"}}'

# Tune the autoscaler (mainly narrowing down the stable window)
oc apply -f openshift-configs/knative-autoscaler-config.yaml

# Open terminator and configure for demo
cd ~/dev/demos/camel-quarkus-demo/getting-further-with-camel-on-quarkus
# Split window horizontally, and run below command in each shell
. openshift-configs/before-running-demo.sh

# Tune the zoom (CTRL + scroll 9x)
# Prepare the watch command in bottom shell
watch "oc describe quota mem-quota && echo '' && oc get pods | grep -v build"
# Zoom in eclipse editor (CTRL/SHIFT/+ 5 times so that we have ~70 chars per line)
# Configure audio input/output to headset
# Copy paste tiny urls so that we can send it very early
# Configure display on a single screen (like for Apache CON @Home & JavaLand)

----

== How to Run the Demo

[source,shell]
----
# Speech: Welcome to this session about Getting started with Camel on Quarkus
# Speech: Senor Software Engineer at Red Hat, Camel contributor
# Speech: Typical camel route, consume message/apply pattern/produce result
# Speech: Quarkus = Kubernetes Java stack tailored for OpenJDK HotSpot and GraalVM
# Speech: Extensions, dev mode, test, jvm & native, build a typical route & compare runtime metrics

# Speech: Ask Apache CON @Home attendees to switch the content presentation to full screen
          Otherwise, they will not see the command and code
# Take care of possible lags = audio/video shift, it's worth waiting few seconds so that everyone could see commands output

# Copy paste tiny urls in browser
# https://tinyurl.com/y2twers4 => Camel Quarkus Extensions List
# https://tinyurl.com/y5ocv87h => Building native executable
# https://tinyurl.com/yykp6b54 => Demo source on github

# Pre-requisistes
java --version
mvnu --version
native-image --version (gcc, glibc, zlib)

# Create project skeleton: Keep all default values
mvnu io.quarkus:quarkus-maven-plugin:1.8.1.Final:create

cd my-quarkus-project
# Speech: Typical camel route => Interaction with multiple technologies or framework => quarkus extension
mvnu quarkus:list-extensions
# Speech: Most camel components available, different mode supported, jvm-only vs native => full list on camel website
mvnu quarkus:add-extensions -Dextensions=platform-http,jsonpath,pdf

# Import in eclipse: ~/dev/demos/camel-quarkus-demo/my-quarkus-project
# Speech: Camel Quarkus Bootstrap, a java class extending RouteBuilder ( JAVA & XML dsl supported )
Create MyRouteBuilder class:
public class MyRouteBuilder extends RouteBuilder {
    @Override
    public void configure() {
        from("platform-http:/hello").setBody(constant("Hello From Camel Quarkus !"));
    }
}

# Speech: Dev mode = Continuous feedback loop
mvnu quarkus:dev

# Speech: Watch changes and update in the blink of an eye
# Kill the watch as it will pollute startup memory in next steps
watch http :8080/hello

# Add MyRouteBuilderTest:
import io.quarkus.test.junit.QuarkusTest
import static io.restassured.RestAssured.given;

@QuarkusTest
public class MyRouteBuilderTest {
    @Test
    void getHelloShouldReturnHttp200(){
        given().when().get("/hello").then().statusCode(200);
    }
}

# Speech: Let's see the test is ok
mvnu clean test

# Then in a second time => build
mvnu install

# We have runner jar in target => this is the JVM Mode
ls target

# Speech: All inclusive disk size ~= runner + lib + java (for java, you'll need at least modules)
# "lib/modules" size ~= openjre11-alpine-image-size - alpine-3.12-image-size (open jre 11.0.9 docker image is based on alpine 3.12)
du -chLs target/my-quarkus-project-1.0-SNAPSHOT-runner.jar target/lib ${JAVA_HOME}/lib/modules

# Speech: Camel boot time / Quarkus boot time
java -jar target/my-quarkus-project-1.0-SNAPSHOT-runner.jar

# Speech: Resident Set Size = everything in RAM in KiB ~= part of shared library + stack + heap that is actually used
ps -o rss,cmd $(pgrep -f my-q)

# Proves that it run
http :8080/hello

# Then show slides while building in native mode (~3 minutes)
mvnu package -P native

# We have a native executable in target => this is the Native Mode
ls target

# Speech: Just enough of application code / third party libs / jdk)
du -chLs target/my-quarkus-project-1.0-SNAPSHOT-runner*
# Speech: Instant startup
target/my-quarkus-project-1.0-SNAPSHOT-runner
# Then rss mem
ps -o rss,cmd $(pgrep -f my-q)
# And finally show it working
http :8080/hello

# Add default message:
# setBody(simple("{{msg}}")). # in route
# camel.default-msg = ItsWorm # in src/main/resources/applications.properties
mvnu quarkus:dev
http :8080/hello
mvnu quarkus:dev -Dmsg=ItsWarm

# Speech: Explains the route logic a bit more
# Speech: It receives an http request with a json body and extract the temperature
# Speech: When the temperature is greater than 30 it issues a message like "It's warm"
# Speech: Otherwise, it issues a message like "It's cold"
# Add some jsonpath logic in route:
#    @Override
#    public void configure() throws Exception {
#        // {room:{temperature:50}}
#        from("platform-http:/hello").
#            choice().when(jsonpath("$.room[?(@.temperature > 30)]")).
#                setBody(simple("{{camel.default-msg}}")).
#            otherwise().
#                setBody(constant("ItsC old")).
#            end();
#    }
watch http :8080/hello <<< '{room: {temperature: 30}}'

# Finally, add pdf generation
# .to("pdf:create?fontSize=26"); 
http :8080/hello <<< '{room : {temperature : 40}}' > test.pdf
firefox test.pdf

# Then run compare.sh
cd ..
# Speech: Now, compare key metrics on different runtimes
# Speech: Same demo on top of Spring Boot, Quarkus JVM Mode and Quarkus Native Mode
# Speech: Estimation of time needed to boot and serve the first request
camel-hellos/compare.sh

# Slides: Show last page
# Speech: This is just a typical route built and tested locally for demo purpose but in the next session Omar may show how to do continuous delivery and deployment on Knative
# Speech: I hope that you now have a better idea of WHY we've created camel-quarkus
# Speech: In a nutshell, it's all about lightweight pattern based integrations running in the cloud
# Speech: Thanks all, time for question, feel free to reach out to the community

# End for now
----------------------------------------------------------------------------------------------------------------------
# In a future demo, then show the resulting densification in a crc cluster with quotas mem ? cpu ? (ideally all hellos project but could be only jvm vs native)
# Launch some requests to scale pods, we would expect native to exhibit a better densification
At first, it's possible to set replicas = 20 and show the time it takes in OpenShift DeploymentConfig view

Raw notes for demo/improvements:
Interest of native mode:
JIT vs AOT => faster startup since code is already pre-compiled into efficient machine code
No need to include JIT infrastructure to load and optimize code at run time => less memory
static analysis to embed what's used from the JDK, 3rd party libs and JVM code
vscode to have auto completion ?
Show quarkus live reload ? (update the dev and show result directly in the cluster)
Does quarkus really improve disk size in jvm mode only ? integrate an unused class and check size for instance ?
It does, when quarkus remove beans, we still have .class file but not files like _Bean.class, _ClientProxy.class

An interest of fast startup is that it improve disposability (help to scale, move process to another node...)
On a public cloud, densification allows the use of smaller instances to run an application so reduce costs
cloud provider portability => need kubernetes to abstract cloud specific services like object bucket storage => then we still need a framework to use those services => Quarkus
Quarkus streamlines the registration process by detecting and auto-registering as many of your codeâ€™s reflection candidates as possible (interest of quarkus on top of graalvm)
JVM mode is simpler, going native could introduce additional steps (eg add some dependencies to indexer)
Check how to simply deploy on openshift (https://developers.redhat.com/blog/2020/04/24/ramp-up-on-quarkus-a-kubernetes-native-java-framework/)
Quarkus, even in JVM mode, moves some typical framework init phase from runtime to build time (load/parse config),
Find annotated class, attempt to load class to enable/disable features, build its model of the world)
An advantage of quarkus jvm mode vs native, is that you have some startup/mem/disk optimization with a quick build phase
Quarkus-native applications bring a much smaller memory footprint at the expense of throughput, which is now handled through scaling and elasticityâ€”the same way you find in Kubernetes
It also brings faster startup speeds at the expense of dynamic runtime behavior, which is now unnecessary overhead in immutable deployment architecturesâ€”again, like you find in Kubernetes
GraalVM operates with a closed world assumption. It analyzes the call tree and removes all the classes/methods/fields that are not used directly.
One size does not fit all! Quarkus gives you the option to scale up in JVM mode if you need a single instance with a larger heap, or scale out in Native mode if you need more, lighter-weight instances

TODO: tool "dive" to get image details, like image base size... to estimate java size ?

TODO: Add a component customization example in demo (like in https://camel.apache.org/camel-quarkus/latest/user-guide/bootstrap.html)
TODO: Show mock inject bean (so we need a test)
TODO: Show XML dsl ? show rest dsl ? Mock inject bean (so we need a test)
TODO: Maybe start with a non arc RouteBuilder, then say oh I need a bean, or whatnot, so add @ApplicationScoped on the route.
      And actually, is there any scenarios where we would take the boot time penalty of using @ApplicationScoped route ?

TODO: Adding a native resource inclusion from application.properties would be good

TODO: https://camel.apache.org/camel-quarkus/latest/user-guide/bootstrap.html#_camel_main 
   Use functionalities from camel-quarkus-main
   configure component by properties camel.component.log.exchange-formatter =  ***
   use convention like, a single ExchangeFormatter instance in the CDI container, then it will automatically wire that bean to the LogComponent
   quarkus command mode ? would need a kind of custom logic before starting camel
   Specify xml route path: camel.main.xml-routes = routes/routes.xml
   Spefify rest dsl: camel.main.xml-rests = rests/rests.xml,
   Route templates ?
   configure camel via microprofile env var config source ?
   https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#environment-variables-mapping-rules

TODO: Maybe add code completion in the demo ?
    https://marketplace.visualstudio.com/items?itemName=redhat.vscode-apache-camel (VS code CQ code completion)
    https://marketplace.eclipse.org/content/language-support-apache-camel (eclipse CQ code completion)
    Quarkus completion may reside in another plugin

TODO: A good demo with knative, insist on some properties offered by fast startup:
A scenario with some intermittent source of events, like an app/platform/something emitting events needing a log of pods:
+ eventA emitted, knative/keda ? detects it, so 20/30 pods from serviceA running to handle it
+ eventB emitted, knative/keda ? detects it, so 20/30 pods from serviceB running to handle it
Events could be anything, I just need two events that are mandatory occurring with a big delay between them (sun up/down).

The example should be built on the fact that eventA and eventB don't need to occur at the same moment in any circumstances.

TODO: It could be better if the demo include the communication of something very old with something very new.
Or something very low level tcp in airplane, communicated with something very high level (an airport service deployed in kubernetes ?)

Find below how to show resources consumption for containers:
watch oc exec hello-cq-knative-native-mode-lswdr-3-deployment-fc89bdd8-9jlc5 cat /sys/fs/cgroup/memory/memory.usage_in_bytes
 50999808 ( 48.64 MiB) in native
613645120 (585.22 MiB) in jvm
To get the sidecar usage, you need to add "-c queue-proxy"
watch oc exec hello-cq-knative-native-mode-yylnv-3-deployment-7fdd977b8f2x2bx -c queue-proxy cat /sys/fs/cgroup/memory/memory.usage_in_bytes

OpenShift Serverless tuning:
The total size requirements to run OpenShift Serverless are dependent on the applications deployed. By default, each pod requests ~400m of CPU, so the minimum requirements are based on this value.

Follow up on Knative tutorial:
https://www.openshift.com/blog/knative-serving-your-serverless-services?extIdCarryOver=true&sc_cid=701f2000001OH7TAAW
