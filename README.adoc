= Camel-Quarkus Demo

== How to Prepare the Demo

[source,shell]
----
# Provision "OpenShift 4 Serverless Foundations Lab" cluster and login, for instance:
oc login https://api.cluster-4098.4098.sandbox1083.opentlc.com:6443

# Create knative-serving namespace
oc create namespace knative-serving

# Install OpenShift ServerLess Operator from the UI (https://docs.openshift.com/container-platform/4.6/serverless/installing_serverless/installing-openshift-serverless.html)
+ Operators/Operator Hub/Fitler (OpenShift ServerLess)
+ Click Install / Subscribe
+ Click "Installed Operators" / "OpenShift Serverless" / "KNative Serving - Create Instance "
+ In the YAML view, set namespace to knative-serving
+ Click create
+ watch oc get pods -n knative-serving (wait all pods to be ready)

# Deploy jvm and native projects to the cluster
upstream
cd ~/dev/demos/camel-quarkus-demo/getting-further-with-camel-on-quarkus
mvn clean package -Dquarkus.kubernetes.deploy=true

# Finalize the configuration
oc apply -f openshift-configs/limit-range.yaml
kn ksvc update hello-cq-knative-jvm-mode --request memory=600Mi
kn ksvc update bye-cq-knative-jvm-mode --request memory=600Mi
kn ksvc update hello-cq-knative-native-mode --request memory=50Mi
kn ksvc update bye-cq-knative-native-mode --request memory=50Mi
oc apply -f openshift-configs/mem-quota.yaml

# Check that mem requests were applied
oc get ksvc hello-cq-knative-jvm-mode -o json | grep request -A 1
oc get ksvc hello-cq-knative-native-mode -o json | grep request -A 1
oc get ksvc bye-cq-knative-jvm-mode -o json | grep request -A 1
oc get ksvc bye-cq-knative-native-mode -o json | grep request -A 1

# Check the knative version (expected 0.16.0)
oc get namespace knative-serving -o 'go-template={{index .metadata.labels "serving.knative.dev/release"}}'

# Tune the autoscaler (mainly narrowing down the stable window)
oc apply -f openshift-configs/knative-autoscaler-config.yaml

# Open terminator and configure for knative demo
cd ~/dev/demos/camel-quarkus-demo/getting-further-with-camel-on-quarkus
# Split window horizontally, and run below command in each shell
. openshift-configs/before-running-demo.sh
# Tune the zoom (CTRL + scroll 9x)
# Prepare the watch command in bottom shell
watch "oc describe quota mem-quota && echo '' && oc get pods | grep -v build"

# Open terminator and configure the local rest demo
cd ~/dev/demos/camel-quarkus-demo/getting-further-with-camel-on-quarkus/rest-to-nats-demo/
git checkout -- .
# Split window horizontally, then horizontally, and run below command in each shell
upstream
# Then run each command below in its own shell
./start-nats.sh
http localhost:8080/steps
mvn quarkus:dev
# Tune the zoom in each shell (CTRL + scroll as necessary)

# In eclipse Open rest-to-nats-demo/rests.xml,Step2Bean,StepsRouteTest,Configurations,application.properties
# In eclipse Open by-cq-knative-jvm-mode/MyRoutBuilder.java
# In openshift console, prepare Serverless/Services with namespace default (we should see the 4 knative services)
# Zoom in eclipse editor (CTRL/SHIFT/+ 5 times so that we have ~70 chars per line)
# Configure audio input/output to headset
# Copy paste tiny urls so that we can send it very early
# Configure display on a single screen (like for Apache CON @Home & JavaLand)

----

== How to Run the Demo

[source,shell]
----
# Speech: Welcome to this session about Getting further with Camel on Quarkus
# Speech: Senior Software Engineer at Red Hat, Camel contributor
# Speech: A short reminder about Camel and Quarkus
# Speech: Then showing camel-quarkus tips with a local project
# speech: Finally illustrating a situation where native mode shine with knative

# Speech: Ask attendees to switch the content presentation to full screen if any
# Take care of possible lags = audio/video shift, it's worth waiting few seconds so that everyone could see commands output

# Copy paste tiny urls in browser if any

# Speech: reminder with slides
# Camel = Consume from 300+ framework/techno => apply proven integration recipes with dsl => produces to 300+ framework/techno
# Quarkus = Tailors Java applications for GraalVM and JDK HotSpot (fast startup, low memory and developer joy)
# Quarkus = JVM mode simple and already doing well vs native mode a bit harder and a step further with Ahead Of Time compilation

# Show the rest DSL, the xml file referenced from the application.properties
# Invoke the service from the middle shell output "STEP 1"
http localhost:8080/steps

# Uncomment bean in rests.xml
# Invoke the service from the middle shell output "STEP 1 - STEP 2"
http localhost:8080/steps

# Show in StepsRouteTest how to override the bean in a test
# Run the JUnit test from eclipse

# Uncomment log in rests.xml
# Invoke the service from the middle shell output logs with MEP and body type
http localhost:8080/steps

# Uncomment @Named on Configurations.log() (camel component tuning via java code)
# Invoke the service from the middle shell output logs without MEP and body type
http localhost:8080/steps

# Uncomment the nats line in rests.xml, and uncomment @Named on ssl() in Configurations
# quarkus:dev can't start
# uncomment nats.servers line in application.properties (camel component tuning via properties)
# Invoke, and show the logs from nats server
http localhost:8080/steps

# Now let's try in native mode
mvn clean package -P native
# Pave the 3 minutes with slides, or explain why @RegisterForReflection is needed
# Recap on native, instant boot time, tiny memory, static code analysis, closed world assumption
target/rest-to-nats-demo-1.0.0-SNAPSHOT-runner
# Oops not running, we need to explicitly embed some resources
# So uncomment 'quarkus.camel.native.resources.include-patterns' in application.properties
mvn clean package -P native
# Explain closed world
# Explain that the rests.xml file is automatically included by the quarkus-XXX extension (@TODO: is it core ? or xml-io ?)
target/rest-to-nats-demo-1.0.0-SNAPSHOT-runner

# Move the knative terminator and present the environment
# Speech: Show a knative service in eclipse, mention kubernetes extension
# Speech: OpenShift cluster = kubernetes with goodies
# Speech: Goodies like serverless tab => 4 services in default namespace
# Speech: bottom shell, quota expand later, and no pods => knative scales to zero

hello-jvm
# On demand provisioning, first request served in 6s

hello-native
# Speech: We save the 3s from the static initializer, so we have seen the boot time effect
# Speech: Wait for knative to scale to zero
# Speech: Explain mem quota, then hello-jvm, at 30s launch bye-jvm, oh needs to wait (it's either delay or dollar)
# Speech: hello-native, bye-native => we have a better densification

# Speech: CONCLUSION
# Speech: I hope that you now have a better idea of HOW camel-quarkus could be used
# Speech: Not only Java, we have seen rest dsl used in xml
# Speech: We can invoke bean and mock them for tests
# Speech: We can programmatically tune camel components with the help of CDI
# Speech: We can configure camel components from application.properties
# Speech: Camel is able to reach bean in the CDI registry
# Speech: Extra concerns in native mode, @RegisterForReflection, include resources
# Speech: We have seen an illustration of boot time and memory effects in an environment with on demand short lived containers
#
# Speech: In a nutshell, it's all about lightweight pattern based integrations running in the cloud
# Speech: Thanks all, time for question, feel free to reach out to the community

----------------------------------------------------------------------------------------------------------------------

Raw notes for demo/improvements:
Show quarkus live reload ? (update the dev and show result directly in the cluster)
Does quarkus really improve disk size in jvm mode only ? integrate an unused class and check size for instance ?
It does, when quarkus remove beans, we still have .class file but not files like _Bean.class, _ClientProxy.class

An interest of fast startup is that it improve disposability (help to scale, move process to another node...)
Cloud provider portability => need kubernetes to abstract cloud specific services like object bucket storage => then we still need a framework to use those services => Quarkus
Quarkus streamlines the registration process by detecting and auto-registering as many of your codeâ€™s reflection candidates as possible (interest of quarkus on top of graalvm)
JVM mode is simpler, going native could introduce additional steps (eg add some dependencies to indexer)
Check how to simply deploy on openshift (https://developers.redhat.com/blog/2020/04/24/ramp-up-on-quarkus-a-kubernetes-native-java-framework/)
One size does not fit all! Quarkus gives you the option to scale up in JVM mode if you need a single instance with a larger heap, or scale out in Native mode if you need more, lighter-weight instances

@TODO: Find which extension is embedding the rests.xml file in the native executable
@TODO: Find a way to have dev mode reloaded each time rests.xml is modified
@TODO: Tune the memory limits (they might use less that 650Mi / 50Mi ?)

Find below how to show resources consumption for containers:
watch oc exec hello-cq-knative-native-mode-lswdr-3-deployment-fc89bdd8-9jlc5 cat /sys/fs/cgroup/memory/memory.usage_in_bytes
 50999808 ( 48.64 MiB) in native
613645120 (585.22 MiB) in jvm
To get the sidecar usage, you need to add "-c queue-proxy"
watch oc exec hello-cq-knative-native-mode-yylnv-3-deployment-7fdd977b8f2x2bx -c queue-proxy cat /sys/fs/cgroup/memory/memory.usage_in_bytes
